{
  "version": 3,
  "sources": ["../src/lib/create-state.ts", "../src/dev/create-state.dev.ts"],
  "sourcesContent": ["import { useEffect, useReducer, useRef } from \"react\";\r\nimport { CreateStateOptions, DeepReadonly } from \"./create-state.types\";\r\n\r\nconst forceReducer = (state: number) => state + 1;\r\n\r\nexport function createState<State, Actions>({\r\n  init,\r\n  reducer,\r\n}: CreateStateOptions<State, Actions>) {\r\n  const handlerMap = new Map<Function, Function>();\r\n  const lastResultMap = new Map<Function, unknown>();\r\n\r\n  const stateHolder = {\r\n    _state: init,\r\n    get state() {\r\n      return this._state;\r\n    },\r\n    set state(newState: State) {\r\n      this._state = newState;\r\n\r\n      for (const [fn, handler] of handlerMap.entries()) {\r\n        // Figure out a way to run handlers for ONLY the changed property\r\n        if (!handler) continue;\r\n\r\n        const lastResult = lastResultMap.get(fn);\r\n        const newResult = fn(this._state);\r\n\r\n        if (newResult != lastResult) {\r\n          lastResultMap.set(fn, newResult);\r\n          handler();\r\n        }\r\n      }\r\n    },\r\n  };\r\n\r\n  function getState() {\r\n    return stateHolder.state as DeepReadonly<State>;\r\n  }\r\n\r\n  async function dispatch(action: Actions) {\r\n    const result = await reducer(action, getState, dispatch);\r\n    stateHolder.state = result as State;\r\n  }\r\n\r\n  function unregister(fn: Function) {\r\n    handlerMap.delete(fn);\r\n    lastResultMap.delete(fn);\r\n  }\r\n\r\n  function useStateSelector<SelectedValue>(\r\n    fn: (state: State) => SelectedValue\r\n  ) {\r\n    const fnRef = useRef(fn);\r\n    const [, rerender] = useReducer(forceReducer, 0);\r\n\r\n    const value = fnRef.current(stateHolder.state);\r\n    handlerMap.set(fnRef.current, rerender);\r\n\r\n    // To unregister the handler when component unmounts\r\n    useEffect(() => () => unregister(fnRef.current), []);\r\n\r\n    return value as SelectedValue;\r\n  }\r\n\r\n  return [dispatch, useStateSelector, getState] as const;\r\n}\r\n\r\nexport default createState;\r\n", "import { CreateStateOptionsWithDevtools } from \"./create-state.dev.types\";\r\nimport { CreateStateOptions, StateReducer } from \"../lib/create-state.types\";\r\n\r\nconst devtoolsName = \"__REDUX_DEVTOOLS_EXTENSION__\";\r\n\r\nlet devtools = (() => {\r\n  try {\r\n    return (window as any)[devtoolsName] || (window.top as any)[devtoolsName];\r\n  } catch (error) {\r\n    return undefined;\r\n  }\r\n})();\r\n\r\nlet instanceId = 0;\r\n\r\nexport function addDevtools<State, Actions>({\r\n  init,\r\n  reducer,\r\n  name,\r\n  replacer,\r\n  reviver,\r\n}: CreateStateOptionsWithDevtools<State, Actions>): CreateStateOptions<\r\n  State,\r\n  Actions\r\n> {\r\n  devtools?.connect({\r\n    name: name || `ProxyState ${instanceId++}`,\r\n    serialize: {\r\n      replacer,\r\n      reviver,\r\n    },\r\n    features: {\r\n      persist: false, // persist states on page reloading\r\n      export: true, // export history of actions in a file\r\n      import: \"custom\", // import history of actions from a file\r\n      jump: false, // jump back and forth (time travelling)\r\n      skip: false, // skip (cancel) actions\r\n      reorder: false, // drag and drop actions in the history list\r\n      dispatch: true, // dispatch custom actions or action creators\r\n      test: true, // generate tests for the selected actions\r\n    },\r\n  });\r\n\r\n  devtools?.send(\"__INIT__\", init);\r\n\r\n  const wrappedReducer: StateReducer<State, Actions> = async (\r\n    action,\r\n    getState,\r\n    dispatch\r\n  ) => {\r\n    const __startTime = new Date().toISOString();\r\n\r\n    const result = reducer(action, getState, dispatch);\r\n    const output = await result;\r\n\r\n    if (result instanceof Promise) {\r\n      devtools?.send(\r\n        {\r\n          ...action,\r\n          __startTime,\r\n          __endTime: new Date().toISOString(),\r\n        },\r\n        output\r\n      );\r\n    } else {\r\n      devtools?.send(action, result);\r\n    }\r\n\r\n    return result as State;\r\n  };\r\n\r\n  return {\r\n    reducer: wrappedReducer,\r\n    init,\r\n  };\r\n}\r\n"],
  "mappings": "AAAA,8DAGA,GAAM,GAAe,AAAC,GAAkB,EAAQ,EAEzC,WAAqC,CAC1C,OACA,WACqC,CACrC,GAAM,GAAa,GAAI,KACjB,EAAgB,GAAI,KAEpB,EAAc,CAClB,OAAQ,KACJ,QAAQ,CACV,MAAO,MAAK,WAEV,OAAM,EAAiB,CACzB,KAAK,OAAS,EAEd,OAAW,CAAC,EAAI,IAAY,GAAW,UAAW,CAEhD,GAAI,CAAC,EAAS,SAEd,GAAM,GAAa,EAAc,IAAI,GAC/B,EAAY,EAAG,KAAK,QAE1B,AAAI,GAAa,GACf,GAAc,IAAI,EAAI,GACtB,QAMR,YAAoB,CAClB,MAAO,GAAY,MAGrB,iBAAwB,EAAiB,CACvC,GAAM,GAAS,KAAM,GAAQ,EAAQ,EAAU,GAC/C,EAAY,MAAQ,EAGtB,WAAoB,EAAc,CAChC,EAAW,OAAO,GAClB,EAAc,OAAO,GAGvB,WACE,EACA,CACA,GAAM,GAAQ,EAAO,GACf,CAAC,CAAE,GAAY,EAAW,EAAc,GAExC,EAAQ,EAAM,QAAQ,EAAY,OACxC,SAAW,IAAI,EAAM,QAAS,GAG9B,EAAU,IAAM,IAAM,EAAW,EAAM,SAAU,IAE1C,EAGT,MAAO,CAAC,EAAU,EAAkB,GC7DtC,GAAM,GAAe,+BAEjB,EAAY,KAAM,CACpB,GAAI,CACF,MAAQ,QAAe,IAAkB,OAAO,IAAY,QAC5D,CACA,YAIA,EAAa,EAEV,WAAqC,CAC1C,OACA,UACA,OACA,WACA,WAIA,CACA,UAAU,QAAQ,CAChB,KAAM,GAAQ,cAAc,MAC5B,UAAW,CACT,WACA,WAEF,SAAU,CACR,QAAS,GACT,OAAQ,GACR,OAAQ,SACR,KAAM,GACN,KAAM,GACN,QAAS,GACT,SAAU,GACV,KAAM,MAIV,GAAU,KAAK,WAAY,GA4BpB,CACL,QA3BmD,MACnD,EACA,EACA,IACG,CACH,GAAM,GAAc,GAAI,QAAO,cAEzB,EAAS,EAAQ,EAAQ,EAAU,GACnC,EAAS,KAAM,GAErB,MAAI,aAAkB,SACpB,GAAU,KACR,IACK,EACH,cACA,UAAW,GAAI,QAAO,eAExB,GAGF,GAAU,KAAK,EAAQ,GAGlB,GAKP",
  "names": []
}
