{
  "version": 3,
  "sources": ["../src/lib/create-state.ts", "../src/dev/add-devtools.ts"],
  "sourcesContent": ["import { useCallback, useEffect, useReducer, useRef, useState } from 'react'\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { CreateStateOptions, DeepReadonly } from './create-state.types'\n\nconst forceUpdate = (state: number) => state + 1\nconst notEqualDefault = (a: unknown, b: unknown) => a !== b\n\nexport function createState<State, Actions>({\n  init,\n  reducer,\n  notEqual = notEqualDefault,\n}: CreateStateOptions<State, Actions>) {\n  const handlerMap = new Map<Function, Function>()\n  const lastResultMap = new Map<Function, unknown>()\n\n  const stateHolder = {\n    _state: init,\n    get state() {\n      return this._state\n    },\n    set state(newState: State) {\n      this._state = newState\n\n      unstable_batchedUpdates(() => {\n        for (const [fn, handler] of handlerMap.entries()) {\n          // Figure out a way to run handlers for ONLY the changed property\n          if (!handler) continue\n\n          const lastResult = lastResultMap.get(fn)\n          const newResult = fn(this._state)\n\n          if (notEqual(newResult, lastResult)) {\n            lastResultMap.set(fn, newResult)\n            handler()\n          }\n        }\n      })\n    },\n  }\n\n  function getState() {\n    return stateHolder.state as DeepReadonly<State>\n  }\n\n  async function dispatch(action: Actions) {\n    const result = await reducer(action, getState, dispatch)\n    stateHolder.state = result as State\n  }\n\n  function unregister(fn: Function) {\n    handlerMap.delete(fn)\n    lastResultMap.delete(fn)\n  }\n\n  function useStateSelector<SelectedValue>(\n    fn: (state: State) => SelectedValue\n  ) {\n    const fnRef = useRef(fn)\n    const value = fnRef.current(stateHolder.state) as SelectedValue\n\n    // re-render mechanism\n    // somehow useState seems to be less blocking than useReducer\n    const [, setState] = useState(0)\n    const rerender = useCallback(() => setState(forceUpdate), [])\n\n    // To unregister the handler when component unmounts\n    useEffect(() => () => unregister(fnRef.current), [])\n\n    if (!handlerMap.has(fnRef.current)) {\n      handlerMap.set(fnRef.current, rerender)\n      lastResultMap.set(fnRef.current, value)\n    }\n\n    return value\n  }\n\n  return [dispatch, useStateSelector, getState] as const\n}\n\nexport default createState\n", "import { CreateStateOptionsWithDevtools } from './add-devtools.types'\nimport { CreateStateOptions, StateReducer } from '../lib/create-state.types'\n\nconst devtoolsName = '__REDUX_DEVTOOLS_EXTENSION__'\n\nlet devtools = (() => {\n  try {\n    return (window as any)[devtoolsName] || (window.top as any)[devtoolsName]\n  } catch (error) {\n    return undefined\n  }\n})()\n\nlet instanceId = 0\n\nexport function addDevtools<State, Actions>({\n  init,\n  reducer,\n  name,\n  replacer,\n  reviver,\n  ...rest\n}: CreateStateOptionsWithDevtools<State, Actions>): CreateStateOptions<\n  State,\n  Actions\n> {\n  if (devtools) {\n    devtools.connect({\n      name: name || `ProxyState ${instanceId++}`,\n      serialize: {\n        replacer,\n        reviver,\n      },\n      features: {\n        persist: false, // persist states on page reloading\n        export: true, // export history of actions in a file\n        import: 'custom', // import history of actions from a file\n        jump: false, // jump back and forth (time travelling)\n        skip: false, // skip (cancel) actions\n        reorder: false, // drag and drop actions in the history list\n        dispatch: true, // dispatch custom actions or action creators\n        test: true, // generate tests for the selected actions\n      },\n    })\n\n    devtools.send('__INIT__', init)\n\n    const wrappedReducer: StateReducer<State, Actions> = async (\n      action,\n      getState,\n      dispatch\n    ) => {\n      const __startTime = new Date().toISOString()\n\n      const result = reducer(action, getState, dispatch)\n      const output = await result\n\n      if (result instanceof Promise) {\n        devtools.send(\n          {\n            ...action,\n            __startTime,\n            __endTime: new Date().toISOString(),\n          },\n          output\n        )\n      } else {\n        devtools.send(action, result)\n      }\n\n      return result as State\n    }\n\n    return {\n      reducer: wrappedReducer,\n      init,\n      ...rest,\n    }\n  } else {\n    return { reducer, init, ...rest }\n  }\n}\n"],
  "mappings": "4xBAAA,6EACA,oDAGA,GAAM,GAAc,AAAC,GAAkB,EAAQ,EACzC,EAAkB,CAAC,EAAY,IAAe,IAAM,EAEnD,WAAqC,CAC1C,OACA,UACA,WAAW,GAC0B,CACrC,GAAM,GAAa,GAAI,KACjB,EAAgB,GAAI,KAEpB,EAAc,CAClB,OAAQ,KACJ,QAAQ,CACV,MAAO,MAAK,WAEV,OAAM,EAAiB,CACzB,KAAK,OAAS,EAEd,EAAwB,IAAM,CAC5B,OAAW,CAAC,EAAI,IAAY,GAAW,UAAW,CAEhD,GAAI,CAAC,EAAS,SAEd,GAAM,GAAa,EAAc,IAAI,GAC/B,EAAY,EAAG,KAAK,QAE1B,AAAI,EAAS,EAAW,IACtB,GAAc,IAAI,EAAI,GACtB,UAOV,YAAoB,CAClB,MAAO,GAAY,MAGrB,WAAwB,EAAiB,gCACvC,GAAM,GAAS,KAAM,GAAQ,EAAQ,EAAU,GAC/C,EAAY,MAAQ,IAGtB,WAAoB,EAAc,CAChC,EAAW,OAAO,GAClB,EAAc,OAAO,GAGvB,WACE,EACA,CACA,GAAM,GAAQ,EAAO,GACf,EAAQ,EAAM,QAAQ,EAAY,OAIlC,CAAC,CAAE,GAAY,EAAS,GACxB,EAAW,EAAY,IAAM,EAAS,GAAc,IAG1D,SAAU,IAAM,IAAM,EAAW,EAAM,SAAU,IAE5C,EAAW,IAAI,EAAM,UACxB,GAAW,IAAI,EAAM,QAAS,GAC9B,EAAc,IAAI,EAAM,QAAS,IAG5B,EAGT,MAAO,CAAC,EAAU,EAAkB,GCzEtC,GAAM,GAAe,+BAEjB,EAAY,KAAM,CACpB,GAAI,CACF,MAAQ,QAAe,IAAkB,OAAO,IAAY,SACrD,EAAP,CACA,YAIA,EAAa,EAEV,WAAqC,EAU1C,CAV0C,QAC1C,QACA,UACA,OACA,WACA,WAL0C,EAMvC,IANuC,EAMvC,CALH,OACA,UACA,OACA,WACA,YAMA,MAAI,GACF,GAAS,QAAQ,CACf,KAAM,GAAQ,cAAc,MAC5B,UAAW,CACT,WACA,WAEF,SAAU,CACR,QAAS,GACT,OAAQ,GACR,OAAQ,SACR,KAAM,GACN,KAAM,GACN,QAAS,GACT,SAAU,GACV,KAAM,MAIV,EAAS,KAAK,WAAY,GA4BnB,GACL,QA3BmD,CACnD,EACA,EACA,IACG,wBACH,GAAM,GAAc,GAAI,QAAO,cAEzB,EAAS,EAAQ,EAAQ,EAAU,GACnC,EAAS,KAAM,GAErB,MAAI,aAAkB,SACpB,EAAS,KACP,OACK,GADL,CAEE,cACA,UAAW,GAAI,QAAO,gBAExB,GAGF,EAAS,KAAK,EAAQ,GAGjB,IAKP,QACG,IAGE,GAAE,UAAS,QAAS",
  "names": []
}
